#include <cmath>                   // for sin, cos
#include <ftxui/dom/elements.hpp>  // for canvas, Element, separator, hbox, operator|, border
#include <ftxui/screen/screen.hpp>  // for Pixel
#include <memory>   // for allocator, shared_ptr, __shared_ptr_access
#include <string>   // for string, basic_string
#include <utility>  // for move
#include <vector>   // for vector, __alloc_traits<>::value_type
#include <cstring>

#include "ftxui/component/component.hpp"  // for Renderer, CatchEvent, Horizontal, Menu, Tab
#include "ftxui/component/component_base.hpp"      // for ComponentBase
#include "ftxui/component/event.hpp"               // for Event
#include "ftxui/component/mouse.hpp"               // for Mouse
#include "ftxui/component/screen_interactive.hpp"  // for ScreenInteractive
#include "ftxui/dom/canvas.hpp"                    // for Canvas
#include "ftxui/screen/color.hpp"  // for Color, Color::Red, Color::Blue, Color::Green, ftxui

using namespace ftxui;

struct Tank {
  int x;
  int y;
  int type = 0;
  int goal_x = -1;
  int goal_y = -1;
};

struct Bullet {
  int x;
  int y;
  int start_x;
  int start_y;
  int destination_x; 
  int destination_y;
  int start_time;
  bool from_enemy = false;
  bool high_speed = false;
  bool hit = false;
  bool has_bounced = false;

  float pathLength() {
    return sqrt(pow(destination_x - start_x, 2) + pow(destination_y - start_y, 2));
  }
};

const int screen_width = 140;
const int screen_height = 100;
const int screen_block_width = screen_width/2;
const int screen_block_height = screen_height/4;

int my_x = 20;
int my_y = 50;

int mouse_x = 10;
int mouse_y = 10;

int lives = 1;
int bulletsLeft = 3;

int current_level = 0;
int max_level = 1;
bool in_level = false;

float speedMultiplier = 1.0;

std::vector<Tank> tanks;
std::vector<Bullet> bullets;
int screen[screen_height/4][screen_width/2];

int current_time = 0;
int lastshot_time = -1000;

int finished_timer = -1;
int map_transition_start = 0;

bool openanimationFinished = false;


void level1() {
  my_x = 20; my_y = 50;

  tanks.push_back({120, 50, 0});

  int tmp[25][70] = {
    {2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,4 }
  };
  for (int x=0; x<screen_block_width; x++) {
    for (int y=0; y<screen_block_height; y++) {
      if (tmp[y][x] == 0) { if (std::rand() % 10 == 0) { tmp[y][x] = 8; }}
    }
  }
  memcpy(&screen, &tmp, 25 * 70 * sizeof(int));
}

void level2() {
  my_x = 20; my_y = 50;

  tanks.push_back({120, 50, 1});
  tanks.push_back({70, 25, 1});
  tanks.push_back({70, 75, 1});

  int tmp[25][70] = {
    {2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,4 }
  };
  for (int x=0; x<screen_block_width; x++) {
    for (int y=0; y<screen_block_height; y++) {
      if (tmp[y][x] == 0) { if (std::rand() % 10 == 0) { tmp[y][x] = 8; }}
    }
  }
  memcpy(&screen, &tmp, 25 * 70 * sizeof(int));
}

void level3() {
  my_x = 20; my_y = 50;

  tanks.push_back({120, 50, 2});
  tanks.push_back({60, 20, 1});
  tanks.push_back({80, 20, 1});
  tanks.push_back({60, 80, 1});
  tanks.push_back({80, 80, 1});

  int tmp[25][70] = {
    {2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,4 }
  };
  for (int x=0; x<screen_block_width; x++) {
    for (int y=0; y<screen_block_height; y++) {
      if (tmp[y][x] == 0) { if (std::rand() % 10 == 0) { tmp[y][x] = 8; }}
    }
  }
  memcpy(&screen, &tmp, 25 * 70 * sizeof(int));
}

void level4() {
  my_x = 20; my_y = 50;

  tanks.push_back({120, 50, 3});
  tanks.push_back({70, 20, 3});
  tanks.push_back({90, 20, 2});
  tanks.push_back({70, 80, 3});
  tanks.push_back({90, 80, 2});

  int tmp[25][70] = {
    {2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,4 }
  };
  for (int x=0; x<screen_block_width; x++) {
    for (int y=0; y<screen_block_height; y++) {
      if (tmp[y][x] == 0) { if (std::rand() % 10 == 0) { tmp[y][x] = 8; }}
    }
  }
  memcpy(&screen, &tmp, 25 * 70 * sizeof(int));
}

void level5() {
  my_x = 20; my_y = 50;

  tanks.push_back({120, 50, 3});
  tanks.push_back({60, 20, 4});
  tanks.push_back({80, 20, 3});
  tanks.push_back({70, 50, 4});
  tanks.push_back({60, 80, 4});
  tanks.push_back({80, 80, 3});

  int tmp[25][70] = {
    {2,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,3 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7 },
    {5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,4 }
  };
  for (int x=0; x<screen_block_width; x++) {
    for (int y=0; y<screen_block_height; y++) {
      if (tmp[y][x] == 0) { if (std::rand() % 10 == 0) { tmp[y][x] = 8; }}
    }
  }
  memcpy(&screen, &tmp, 25 * 70 * sizeof(int));
}

void loadLevel(int level) {
  if (level > max_level) { return; }

  tanks.clear();
  if (level == 1) { level1(); }
  if (level == 2) { level2(); }
  if (level == 3) { level3(); }
  if (level == 4) { level4(); }
  if (level == 5) { level5(); }
  current_level = level;

  in_level = true;
}

void shoot() {
  if (bulletsLeft > 0) {
    lastshot_time = current_time;
    bulletsLeft --;
    bullets.push_back({my_x, my_y, my_x, my_y, mouse_x, mouse_y, current_time, false, false});
  }
}

void enemyBullet(int from_x, int from_y, int to_x, int to_y, bool highSpeed) {
  bullets.push_back({from_x, from_y, from_x, from_y, to_x, to_y, current_time, true, highSpeed});
}

float linear_blend(float a, float b, float t) {
  return a * (1 - t) + b * t;
}

void finishedLevel() { 
  finished_timer = current_time + 100;
  map_transition_start = finished_timer;
}

template <typename T>
void removeItemReLoop(std::vector<T> &v, int &index) {
  if (index != v.size()-1) {
    v[index] = v[v.size()-1];
    index--;
  }
  v.pop_back();
}

bool noCollisionInBlock(int y, int x) {
  return screen[y][x] == 0 || screen[y][x] >= 8;
}
bool noCollision(int y, int x) { return noCollisionInBlock(y/4, x/2); }

inline int sigmoid(int v) { return v > 0 ? 1 : (v < 0 ? -1 : 0); }
inline int sigE(int v, int epsilon) { return v > epsilon ? 1 : (v < epsilon? -1 : 0); }

float vectorlength(int x, int y, int x2, int y2) {
  return sqrt(pow(x2-x, 2) + pow(y2-y, 2));
}

void drawLevel(Canvas& c) {
  for (int x=0; x<screen_block_width; x++) {
    for (int y=0; y<screen_block_height; y++) {
      if (screen[y][x] == 0) { continue; }
      if (screen[y][x] == 1) { c.DrawText(x*2, y*4, "█", Color::RosyBrown); }
      if (screen[y][x] == 2) { c.DrawText(x*2, y*4, "╔", Color::RosyBrown); }
      if (screen[y][x] == 3) { c.DrawText(x*2, y*4, "╗", Color::RosyBrown); }
      if (screen[y][x] == 4) { c.DrawText(x*2, y*4, "╝", Color::RosyBrown); }
      if (screen[y][x] == 5) { c.DrawText(x*2, y*4, "╚", Color::RosyBrown); }
      if (screen[y][x] == 6) { c.DrawText(x*2, y*4, "═", Color::RosyBrown); }
      if (screen[y][x] == 7) { c.DrawText(x*2, y*4, "║", Color::RosyBrown); }
      if (screen[y][x] == 8) { c.DrawText(x*2, y*4, "░", Color::Green4); }
      if (screen[y][x] == 9) { c.DrawText(x*2, y*4, "▒", Color::Green4); } // ¤
      
    }
  }
}

int hoversLevel() {
  if (mouse_x > 10  && mouse_x < 10 +30 && mouse_y > 90 - 10 && mouse_y < 90 + 5) return 1;
  if (mouse_x > 40  && mouse_x < 40 +30 && mouse_y > 70 - 10 && mouse_y < 70 + 5) return 2;
  if (mouse_x > 85  && mouse_x < 85 +30 && mouse_y > 50 - 10 && mouse_y < 50 + 5) return 3;
  if (mouse_x > 45  && mouse_x < 45 +30 && mouse_y > 30 - 10 && mouse_y < 30 + 5) return 4;
  if (mouse_x > 114 && mouse_x < 114+30 && mouse_y > 20 - 10 && mouse_y < 20 + 5) return 5;
  return -1;
}

int main(int argc, const char* argv[]) {

  auto levelSelect = Renderer([&] {
    auto c = Canvas(screen_width, screen_height);

    if (current_level == 0) {
      int posd = 100 - current_time;
      if (posd < -100) { current_level = 1; current_time = 0; openanimationFinished = true; }

      c.DrawText(0,std::max(20,posd) + 0,  R"(                            _-o#&&*''''?d:>b\_                        )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 4,  R"(                      _o/"`''  '',, dMF9MMMMMHo_                      )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 8,  R"(                   .o&#'        `"MbHMMMMMMMMMMMHo.                   )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 12, R"(                 .o"" '         vodM*$&&HMMMMMMMMMM?.                 )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 16, R"(                ,'              $M&ood,~'`(&##MMMMMMH\                )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 20, R"(               /               ,MMMMMMM#b?#bobMMMMHMMML               )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 24, R"(              &              ?MMMMMMMMMMMMMMMMM7MMM$R*Hk              )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 28, R"(             ?$.            :MMMMMMMMMMMMMMMMMMM/HMMM|`*L             )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 32, R"(            |               |MMMMMMMMMMMMMMMMMMMMbMH'   T,            )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 36, R"(            $H#:            `*MMMMMMMMMMMMMMMMMMMMb#}'  `?            )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 40, R"(            ]MMH#             ""*""""*#MMMMMMMMMMMMM'    -            )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 44, R"(            MMMMMb_                   |MMMMMMMMMMMP'     :            )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 48, R"(            HMMMMMMMHo                 `MMMMMMMMMT       .            )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 52, R"(            ?MMMMMMMMP                  9MMMMMMMM}       -            )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 56, R"(            -?MMMMMMM                  |MMMMMMMMM?,d-    '            )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 60, R"(             :|MMMMMM-                 `MMMMMMMT .M|.   :             )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 64, R"(              .9MMM[                    &MMMMM*' `'    .              )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 68, R"(               :9MMk                    `MMM#"        -               )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 72, R"(                 &M}                     `          .-                )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 76, R"(                  `&.                             .                   )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 80, R"(                    `~,   .                     ./                    )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 84, R"(                        . _                  .-                       )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 88, R"(                          '`--._,dd###pp=""'                          )", Color::Green4);
      c.DrawText(0,std::max(20,posd) + 92, R"(░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░)", Color::Green4);

      int w = 4, h = 3;
      int cw = screen_width / 2, ch = screen_height / 2;
      float t = std::min(1.0f, std::max(0.0f, (((float)current_time) / 200.0f) - 0.5f) * 2.0f);

      if ( t > 0.0f) {
        c.DrawPointLine(cw-w, ch+h, cw+w, ch+h, Color::White);
        c.DrawPointLine(cw+w, ch+h, cw+w, ch-h, Color::White);
        c.DrawPointLine(cw+w, ch-h, cw-w, ch-h, Color::White);
        c.DrawPointLine(cw-w, ch-h, cw-w, ch+h, Color::White);

        c.DrawPointLine(cw-w, ch-h, linear_blend(cw-w, 56, t),linear_blend(ch-h, 2, t), Color::White);
        c.DrawPointLine(cw+w, ch-h, linear_blend(cw+w,140, t),linear_blend(ch-h,12, t), Color::White);
        c.DrawPointLine(cw+w, ch+h, linear_blend(cw+w, 96, t),linear_blend(ch+h,96, t), Color::White);
        c.DrawPointLine(cw-w, ch+h, linear_blend(cw-w,  0, t),linear_blend(ch+h,96, t), Color::White);

        c.DrawPointLine(linear_blend(cw-w, 56, t),linear_blend(ch-h, 2, t), linear_blend(cw+w,140, t),linear_blend(ch-h,12, t), Color::White);
        c.DrawPointLine(linear_blend(cw+w,140, t),linear_blend(ch-h,12, t), linear_blend(cw+w, 96, t),linear_blend(ch+h,96, t), Color::White);
        c.DrawPointLine(linear_blend(cw+w, 96, t),linear_blend(ch+h,96, t), linear_blend(cw-w,  0, t),linear_blend(ch+h,96, t), Color::White);
        c.DrawPointLine(linear_blend(cw-w,  0, t),linear_blend(ch+h,96, t), linear_blend(cw-w, 56, t),linear_blend(ch-h, 2, t), Color::White);
      }


      return canvas(std::move(c));
    }

    if (current_level == 5) {
      int post = 28;
      c.DrawText(0,post + 0,  R"(               [        WHILE DEATH IS INEVITABLE         ]           )", Color::White);
      c.DrawText(0,post + 4,  R"(               [ WE CAN ATLEAST TRY TO NOT KILL EACHOTHER ]           )", Color::White);
      c.DrawText(0,post + 8,  R"(                                                                      )", Color::White);
      c.DrawText(0,post + 12, R"(                                             [       ]                )", Color::White);
      c.DrawText(0,post + 16, R"(                                                                      )", Color::White);
      c.DrawText(0,post + 20, R"(                                                       [   ]          )", Color::White);
      c.DrawText(0,post + 24, R"(              *   %               *                                   )", Color::White);
      c.DrawText(0,post + 28, R"(              % *                        *                    [ ]     )", Color::White);
      c.DrawText(0,post + 32, R"(               *% %                  %                                )", Color::White);
      c.DrawText(0,post + 36, R"(       ____|____*$____\_____        *  *                         |    )", Color::White);
      c.DrawText(0,post + 40, R"(      / ___________________ \        *% %            _                )", Color::White);
      c.DrawText(0,post + 44, R"(      \/ _===============_ \/       __*$_ $|===========+        /     )", Color::White);
      c.DrawText(0,post + 48, R"(        "-===============-"       \_______/               ==mmm0      )", Color::White);
      c.DrawText(0,post + 52, R"(░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░)", Color::White);
      
      return canvas(std::move(c));
    }    

    int size = 20;
    double map_transition = ((double)(current_time - map_transition_start)) / 25.0;

    float my = (mouse_y - 95) / -5.f;
    float mx = (mouse_x - 3 * my) / 5.f;
    std::vector<std::vector<float>> ys(size, std::vector<float>(size));
    for (int y = 0; y < size; y++) {
      for (int x = 0; x < size; x++) {
        float dx = x - mx;
        float dy = y - my;
        ys[y][x] = -1.5 + std::pow(std::exp(-0.2f * (dx * dx + dy * dy)), 2);
        ys[y][x] += std::clamp(map_transition, 0.0, 1.0) * (0.5 * std::cos(0.5 * x) + 0.5 * std::cos(0.5 * y) + 0.1 * std::cos(0.5 * y * x));
      }
    }
    for (int y = 0; y < size; y++) {
      for (int x = 0; x < size; x++) {
        if (x != 0) {
          c.DrawPointLine(
              5 * (x - 1) + 3 * (y - 0), 90 - 5 * (y - 0) - 5 * ys[y][x - 1],
              5 * (x - 0) + 3 * (y - 0), 90 - 5 * (y - 0) - 5 * ys[y][x]);
        }
        if (y != 0) {
          c.DrawPointLine(
              5 * (x - 0) + 3 * (y - 1), 90 - 5 * (y - 1) - 5 * ys[y - 1][x],
              5 * (x - 0) + 3 * (y - 0), 90 - 5 * (y - 0) - 5 * ys[y][x]);
        }
      }
    }

    int hover = hoversLevel();
    if (map_transition > 0.9) {
      c.DrawPointLine(5,  90, 30, 67,  (max_level >= 2) ? Color::Green : Color::Red);
      c.DrawPointLine(30, 67, 80, 50,  (max_level >= 3) ? Color::Green : Color::Red);
      c.DrawPointLine(80, 50, 60, 30,  (max_level >= 4) ? Color::Green : Color::Red);
      c.DrawPointLine(60, 30, 110, 20, (max_level >= 5) ? Color::Green : Color::Red);
    } if (map_transition > 1.0) {
      c.DrawText(15, 90 - (hover == 1 ? 4 : 0), hover == 1 ? "[Level 1]" : "Level 1", Color::Green);
      c.DrawText(40, 70 - (hover == 2 ? 4 : 0), hover == 2 ? "[Level 2]" : "Level 2", (max_level >= 2) ? Color::Green : Color::Red);
      c.DrawText(85, 50 - (hover == 3 ? 4 : 0), hover == 3 ? "[Level 3]" : "Level 3", (max_level >= 3) ? Color::Green : Color::Red);
      c.DrawText(45, 30 - (hover == 4 ? 4 : 0), hover == 4 ? "[Level 4]" : "Level 4", (max_level >= 4) ? Color::Green : Color::Red);
      c.DrawText(114,20 - (hover == 5 ? 4 : 0), hover == 5 ? "[Level 5]" : "Level 5", (max_level >= 5) ? Color::Green : Color::Red);
    }

    return canvas(std::move(c));
  });

  // A triangle following the mouse, using braille characters.
  auto renderer_line_braille = Renderer([&] {
    if (in_level == false) { return levelSelect->Render(); }

    auto c = Canvas(screen_width, screen_height);

    if (lives > 0) { c.DrawPointLine(mouse_x, mouse_y, my_x, my_y, Color::GrayLight);}
    c.DrawText(mouse_x, mouse_y, "X", Color::GrayDark);
    
    drawLevel(c);

    if (tanks.size() == 0 && finished_timer == -1) {
      finishedLevel();
    }

    if (finished_timer != -1 && finished_timer < current_time || lives == 0) {
      in_level = false;
      if (lives > 0) { max_level = std::max(current_level + 1, max_level); }
      tanks.clear();
      bullets.clear();
      lives = 1;
      bulletsLeft = 3;
      finished_timer = -1;
    }

    for (int tank_index=0; tank_index<tanks.size(); tank_index++) {
      auto& tank = tanks[tank_index];
      Color color = Color::Red;
      if (tank.type == 0) { color = Color::Red; }
      if (tank.type == 1) { color = Color::Orange1; }
      if (tank.type == 2) { color = Color::Yellow1; }
      if (tank.type == 3) { color = Color::Purple; }
      if (tank.type == 4) { color = Color::White; }
      c.DrawText(tank.x, tank.y, "█", color);

      if (tank.type == 0 && current_time % 200 == 199) { enemyBullet(tank.x, tank.y, my_x, my_y, false); }
      if (tank.type == 1 && current_time % 200 == 49 + std::rand() % 50) { enemyBullet(tank.x, tank.y, my_x, my_y, false); }
      if (tank.type == 2 && current_time % 100 == 49 + std::rand() % 50) { enemyBullet(tank.x, tank.y, my_x, my_y, true); }
      if (tank.type == 3 && current_time % 100 == 49 + std::rand() % 50) { enemyBullet(tank.x, tank.y, my_x, my_y, true); }

      if ((tank.type == 1 || tank.type == 2) && current_time % 100 == std::rand() % 50) { tank.goal_x = my_x; tank.goal_y = my_y; }
      if (tank.type == 4                     && current_time % 15  == std::rand() % 10) { tank.goal_x = my_x; tank.goal_y = my_y; }

      if (tank.goal_x != -1 && current_time % 15 == 0) {
        if(noCollision(tank.y, tank.x+1) && noCollision(tank.y, tank.x-1)) { tank.x += (tank.goal_x - tank.x) > 1 ? 1 : -1; }
        if(noCollision(tank.y+1, tank.x) && noCollision(tank.y-1, tank.x)) { tank.y += (tank.goal_y - tank.y) > 1 ? 1 : -1; }
      }
      
      if (tank.type > 3 && current_time % 100 == 49 + std::rand() % 50) {
        int to_x = ((float)(my_x - tank.x)) / 2.0f;
        int to_y = ((float)(my_y - tank.y)) / 2.0f;
        int finalx = tank.x + to_x - to_y;
        int finaly = tank.x + to_y + to_x;
        enemyBullet(tank.x, tank.y, finalx, finaly, true);
      }

      for (auto& bullet : bullets) { // Hit from player bullet
        if (bullet.from_enemy == false && std::abs(bullet.x - tank.x) < 2 && std::abs(bullet.y - tank.y) < 4) {
          c.DrawText(tank.x, tank.y, "X", Color::Red);
          removeItemReLoop(tanks, tank_index);
          bullet.hit = true;
        }
      }
    }


    for (int bullet_index=0; bullet_index<bullets.size(); bullet_index++) {
      auto& bullet = bullets[bullet_index];
      bullet.x = round(linear_blend(bullet.start_x, bullet.destination_x, ((float)(current_time - bullet.start_time)) / (speedMultiplier * bullet.pathLength())));
      bullet.y = round(linear_blend(bullet.start_y, bullet.destination_y, ((float)(current_time - bullet.start_time)) / (speedMultiplier * bullet.pathLength())));
      
      if(noCollision(bullet.y, bullet.x) == false) { 
        if (bullet.has_bounced) {  if(bullet.start_x != bullet.x && bullet.start_y != bullet.y) { bullet.hit = true; } }
        else {
          bullet.has_bounced = true;
          bool horizontal = screen[bullet.y/4][bullet.x/2] == 6;
          bool vertical   = screen[bullet.y/4][bullet.x/2] == 7;
          bullet.destination_x = vertical ? bullet.start_x : (bullet.destination_x - bullet.start_x) * 2;
          bullet.destination_y = horizontal ? bullet.start_x : (bullet.destination_y - bullet.start_y) * 2;
          bullet.start_x = bullet.x;
          bullet.start_y = bullet.y;
          bullet.start_time = current_time;
        }} 
      if(bullet.from_enemy && std::abs(bullet.x - my_x) < 2 && std::abs(bullet.y - my_y) < 2) { bullet.hit = true; lives = 0; } // bullet hit player


      c.DrawText(bullet.x, bullet.y, bullet.hit ? "x" : "*", bullet.from_enemy ? Color::Red : Color::Blue);
      if (bullet.hit) { 
        if (bullet.from_enemy == false) { bulletsLeft ++; }
        removeItemReLoop(bullets, bullet_index); 
      }
    }
    if (lives > 0) { c.DrawText(my_x, my_y, "█", Color::Blue); }

    return canvas(std::move(c));
  });

  auto tankInfo = Renderer([&] {
    auto c = Canvas(140, 20);
    if (in_level == false) { return canvas(std::move(c)); }

    if ((current_time / 4) % 8 == 0) {
      c.DrawText(0,0,  "  .---.", Color::Blue);
      c.DrawText(0,4,  " /  |  \\  ", Color::Blue);
      c.DrawText(0,8,  ";   |   ;", Color::Blue);
      c.DrawText(0,12, " \\     /", Color::Blue);
      c.DrawText(0,16, "  '---'", Color::Blue);
    }
    
    if ((current_time / 4) % 8 == 1) {
      c.DrawText(0,0,  "  .---.", Color::Blue);
      c.DrawText(0,4,  " /   / \\  ", Color::Blue);
      c.DrawText(0,8,  ";   /   ;", Color::Blue);
      c.DrawText(0,12, " \\     /", Color::Blue);
      c.DrawText(0,16, "  '---'", Color::Blue);
    }

    if ((current_time / 4) % 8 == 2) {
      c.DrawText(0,0,  "  .---.", Color::Blue);
      c.DrawText(0,4,  " /     \\  ", Color::Blue);
      c.DrawText(0,8,  ";   ----;", Color::Blue);
      c.DrawText(0,12, " \\     /", Color::Blue);
      c.DrawText(0,16, "  '---'", Color::Blue);
    }

    if ((current_time / 4) % 8 == 3) {
      c.DrawText(0,0,  "  .---.", Color::Blue);
      c.DrawText(0,4,  " /     \\  ", Color::Blue);
      c.DrawText(0,8,  ";   \\   ;", Color::Blue);
      c.DrawText(0,12, " \\   \\ /", Color::Blue);
      c.DrawText(0,16, "  '---'", Color::Blue);
    }

    if ((current_time / 4) % 8 == 4) {
      c.DrawText(0,0,  "  .---.", Color::Blue);
      c.DrawText(0,4,  " /     \\  ", Color::Blue);
      c.DrawText(0,8,  ";   |   ;", Color::Blue);
      c.DrawText(0,12, " \\  |  /", Color::Blue);
      c.DrawText(0,16, "  '---'", Color::Blue);
    }

    if ((current_time / 4) % 8 == 5) {
      c.DrawText(0,0,  "  .---.", Color::Blue);
      c.DrawText(0,4,  " /     \\  ", Color::Blue);
      c.DrawText(0,8,  ";   /   ;", Color::Blue);
      c.DrawText(0,12, " \\ /   /", Color::Blue);
      c.DrawText(0,16, "  '---'", Color::Blue);
    }

    if ((current_time / 4) % 8 == 6) {
      c.DrawText(0,0,  "  .---.", Color::Blue);
      c.DrawText(0,4,  " /     \\", Color::Blue);
      c.DrawText(0,8,  ";----   ;", Color::Blue);
      c.DrawText(0,12, " \\     /", Color::Blue);
      c.DrawText(0,16, "  '---'", Color::Blue);
    }

    if ((current_time / 4) % 8 >= 7) {
      c.DrawText(0,0,  "  .---.", Color::Blue);
      c.DrawText(0,4,  " /\\    \\", Color::Blue);
      c.DrawText(0,8,  ";  \\    ;", Color::Blue);
      c.DrawText(0,12, " \\     /", Color::Blue);
      c.DrawText(0,16, "  '---'", Color::Blue);
    }

    for (auto &tank : tanks) {
      int error = 4;
      if (sigE(my_y - tank.y, error) ==  1 && sigE(tank.x - my_x, error) ==  0) c.DrawText(8, 0,  "x", Color::Red);
      if (sigE(my_y - tank.y, error) ==  1 && sigE(tank.x - my_x, error) ==  1) c.DrawText(12,0,  "x", Color::Red);
      if (sigE(my_y - tank.y, error) ==  0 && sigE(tank.x - my_x, error) ==  1) c.DrawText(16,8,  "x", Color::Red);
      if (sigE(my_y - tank.y, error) == -1 && sigE(tank.x - my_x, error) ==  1) c.DrawText(12,16, "x", Color::Red);
      if (sigE(my_y - tank.y, error) == -1 && sigE(tank.x - my_x, error) ==  0) c.DrawText(8, 16, "x", Color::Red);
      if (sigE(my_y - tank.y, error) == -1 && sigE(tank.x - my_x, error) == -1) c.DrawText(4, 16, "x", Color::Red);
      if (sigE(my_y - tank.y, error) ==  0 && sigE(tank.x - my_x, error) == -1) c.DrawText(0, 8,  "x", Color::Red);
      if (sigE(my_y - tank.y, error) ==  1 && sigE(tank.x - my_x, error) == -1) c.DrawText(4, 0,  "x", Color::Red);
    }

    c.DrawText(20,16,"░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░", Color::Green4);

    int post = current_time % 30;
  
    int dist = 0;
    if (finished_timer != -1) { dist = linear_blend(120, 0.0, ((float)(finished_timer - current_time)) / 100.0); }

    c.DrawText(20 + dist,4, "  __", Color::Blue);
    c.DrawText(20 + dist,8, "|\"\"\"\\-=", Color::Blue);
    c.DrawText(20 + dist,12,"(____)", Color::Blue);

    if (current_time - lastshot_time < 20) {
      c.DrawText(20 + dist,0, "         __,-.", Color::Blue);
      c.DrawText(20 + dist,4, "  __    ( .`-')", Color::Blue);
      c.DrawText(20 + dist,8, "|\"\"\"\\-=(_ (_,_)", Color::Blue);
      c.DrawText(20 + dist,12,"(____)   `--'", Color::Blue);
    }

    int i = 0;
    for (auto &tank : tanks) {
      i ++;
      c.DrawText(140 - i*2*7,4, "    __ ", Color::Red);
      c.DrawText(140 - i*2*7,8, "=-/\"\"\"|", Color::Red);
      c.DrawText(140 - i*2*7,12," (____)", Color::Red);
    }

    return canvas(std::move(c));
  });

  auto information_screen = Renderer([&] {
    if (openanimationFinished != true) { return vbox({ text("                   "), }); }

    return vbox({
            text("Hover & click to "),
            text("       select level"),
            text(""),
            text("Level: " + std::to_string(current_level)),
            text("Current time: " + std::to_string(current_time)),
            text(""),
            text("Bullets left: " + std::to_string(bulletsLeft)),
            text("Tanks left: " + std::to_string(tanks.size())),
            text(""),
            text("Max level: " + std::to_string(max_level)),
            text(""),
            text(""),
            text("Mouse to move"),
            text("Left Click to shoot"),
            text(""),
            text(""),
            text(""),
            text("HINT: Life is hard"),
            text("but getting hit"),
            text("by an enemy bullet"),
            text("would not make it"),
            text("better."),
          });
  });

  int selected_tab = 1;   
  auto tab = Container::Tab(
      {
          renderer_line_braille,
      },
      &selected_tab);

  // This capture the last mouse position.
  auto tab_with_mouse = CatchEvent(tab, [&](Event e) {
    if (e.is_mouse()) {
      mouse_x = (e.mouse().x - 1) * 2;
      mouse_y = (e.mouse().y - 1) * 4;
      mouse_x = std::max(2, std::min(mouse_x, screen_width - 4));
      mouse_y = std::max(4, std::min(mouse_y, screen_height - 8));
    }

    if (current_time % 4 == 0) {
      if (std::abs(mouse_x - my_x) > std::abs(mouse_y - my_y)){
        if ((mouse_x - my_x) >=  2) {if(noCollision(my_y+0,my_x+1)) my_x += 1; }
        if ((mouse_x - my_x) <= -2) {if(noCollision(my_y+0,my_x-1)) my_x -= 1; }
      } else {
        if ((mouse_y - my_y) >=  4) {if(noCollision(my_y+1,my_x+0)) my_y += 2; }
        if ((mouse_y - my_y) <= -4) {if(noCollision(my_y-1,my_x+0)) my_y -= 2; }
      }
    }

    // if (e.is_character()) {
    //   if (e.character().compare("w")) { if(noCollision(my_y+1,my_x+0)) my_y ++; }
    //   if (e.character().compare("s")) { if(noCollision(my_y-1,my_x+0)) my_y --; }
    //   if (e.character().compare("a")) { if(noCollision(my_y+0,my_x+1)) my_x ++; }
    //   if (e.character().compare("d")) { if(noCollision(my_y+0,my_x-1)) my_x --; }
    // }
    if (e.is_mouse()) {
      if (e.mouse().button == Mouse::Button::Left && e.mouse().motion == Mouse::Motion::Released) { 
        if (in_level == true) { shoot(); }
        else { if (hoversLevel() != -1) { loadLevel(hoversLevel()); }}
      }
    }
    return false;
  });

 auto component = Container::Horizontal({
      tab_with_mouse,
  });
  // Add some separator to decorate the whole component:
  auto component_renderer = Renderer(component, [&] {
    return hbox({
              vbox({tab_with_mouse->Render(), tankInfo->Render()}),
              separator(),
              information_screen->Render(),
           }) |
           border;
  });

  auto screen = ScreenInteractive::FitComponent();

  bool refresh_ui_continue = true;
  std::thread refresh_ui([&] {
    while (refresh_ui_continue) {
      using namespace std::chrono_literals;
      std::this_thread::sleep_for(0.05s);
      current_time++;
      screen.PostEvent(Event::Custom);
    }
  });

  screen.Loop(component_renderer);
  refresh_ui_continue = false;
  refresh_ui.join();

  return 0;
}